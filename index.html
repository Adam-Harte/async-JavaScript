<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<script src="app.js"></script>
		<title>Async JavaScript</title>
	</head>
	<body>
		<h1>Async JavaScript</h1>
		<h3>Synchronous Code</h3>
		<p>
			JavaScript is single-threaded meaning that only one task/piece of code can
			be exectured at a time due to their only being one thread available to run
			the exection. This means JavaScript code runs from top to bottom line by
			line and step by step.
		</p>
		<h3>Asynchronous Code</h3>
		<p>
			Sometimes we have certain operations in our code that takes longer such as
			timers and HTTP requests. Now we wouldnt want these lengthy operations to
			execute and block the main thread as then the rest of our synchronous code
			cannot run until the operation is complete. To deal with these lengthy
			operations we can send them off to the browser which uses multiple threads
			to deal with such as browser APIs for timers like setTimeout and
			setInterval, event listeners or HTTP requests with fetch. These browser
			APIs typically take a callback fuction that is called later on in the
			single threaded synchronous JavaScript once the lenghty operarion has
			completed.
		</p>
		<h3>Event Loop</h3>
		<p>
			The event loop is used in browsers to manage asynchronous code and
			callbacks. For example say we use a setTimeout that setTimeout will
			execute immediately as a browser API the browser will handle the setting
			of this timer and then add the callback to what is known as the message
			queue. Then after your setTimeout the rest of the synchronous code carries
			on running as normal, After the timer has finished the browser event loop
			will look for a time when the call stack is empty to then go ahead and add
			that queued message being our callback to the stack to then be executed as
			part of synchronous code. The event loop is what snchronises the message
			queue witht the call stack. The event loop is always running checking for
			if the call stack is empty and if it is adds any messages queued that need
			to be added to the stack.
		</p>
		<h3>Promises</h3>
		<p>
			Promises allow us to handle our asyncchronous code/callbacks in a more
			synchronous looking way and helps us avoid the confusion of 'callback
			hell' when we have multiple nested callbacks that can be hard to follow.
			Promises allow us to chain callback executions together with ''.then'
			following on from the previous calls return and therefore keep the code on
			one nested level instead of possible multi nested levels when there is
			multiple callbacks. Promises are an object that takes a function as an
			argument with that function containing two more functions being a resolve
			and reject function and can be created with the 'new Promise()'' syntax.
			The '.then' chaining on a promise begins after resolve has executed and a
			promise can resolve multiple times hence multiple '.then' chaining.
		</p>
		<h3>Chaining Multiple Promises</h3>
		<p>
			Promises can be chained with multiple '.then' by simply adding a return in
			the previous '.then' block. Doing this sets the promise from resolved back
			to pending as it automatically wraps a new promise on the return from the
			previous then. Your next then can then get the data from that previous
			return as a parameter in the callback of '.then' and the chain can keep
			continuing like this. Note that you dont have to return a promise to chain
			multiple '.then' anything you return gets wrapped in a promise and sets
			the promise from resolved back to pending.
		</p>
	</body>
</html>
